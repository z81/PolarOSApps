// Generated by CoffeeScript 1.6.3
(function() {
  var ElementConf, Paper, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Paper = (function(_super) {
    __extends(Paper, _super);

    function Paper() {
      _ref = Paper.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return Paper;

  })(window.PixiAdapter);

  window.getConf = function() {
    return Scheme.getConf();
  };

  ElementConf = (function() {
    function ElementConf() {}

    ElementConf.getConf = function(name, parse) {
      var Inherit, conf, i_conf, _i, _len, _ref1;
      if (parse == null) {
        parse = true;
      }
      conf = {};
      $.ajax({
        url: "hiasm/delphi_utf/conf/" + name + ".ini",
        async: false
      }).success(function(data) {
        return conf = parseINIString(data);
      });
      if (conf.Type && conf.Type.Inherit) {
        _ref1 = conf.Type.Inherit.split(',');
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          Inherit = _ref1[_i];
          i_conf = this.getConf(Inherit, false);
          conf.Property = angular.extend(conf.Property, i_conf.Property);
          conf.Methods = angular.extend(conf.Methods, i_conf.Methods);
        }
      }
      if (parse) {
        return this.parse(conf);
      } else {
        return conf;
      }
    };

    ElementConf.parse = function(conf) {
      var method, name, prop, _ref1, _ref2;
      for (name in conf.Property) {
        prop = {};
        prop.doWork = name.indexOf('@') > -1;
        prop["default"] = name.indexOf('+' > -1);
        prop.name = name.replace(/[@|\+]/gmi, '');
        _ref1 = conf.Property[name].split('|'), prop.description = _ref1[0], prop.type = _ref1[1], prop.value = _ref1[2], prop.list = _ref1[3];
        delete conf.Property[name];
        conf.Property[prop.name] = prop;
      }
      for (name in conf.Methods) {
        method = {};
        method.noVisible = name.indexOf('*');
        method.Name = name.replace(/[\*]/gmi, '');
        _ref2 = conf.Methods[name].split('|'), method.description = _ref2[0], method.type = _ref2[1], method.value = _ref2[2];
        delete conf.Methods[name];
        conf.Methods[method.Name] = method;
      }
      return conf;
    };

    return ElementConf;

  })();

  window.Scheme = (function() {
    var DATA, EVENT, VAR, WORK;

    function Scheme() {}

    WORK = "1";

    EVENT = "2";

    DATA = "3";

    VAR = "4";

    Scheme.getConf = function() {
      return window.scheme_conf;
    };

    Scheme.newPath = function(start_x, start_y, stop_x, stop_y, color) {
      var path;
      path = [];
      if (color === Scheme.getConf().link.color.events) {
        if (start_y - stop_y !== 0) {
          if (start_x < stop_x) {
            path = [start_x + (stop_x - start_x) / 2, start_y, start_x + (stop_x - start_x) / 2, stop_y];
          } else {
            path = [start_x + 10, start_y, start_x + 10, start_y + 30, stop_x - 10, start_y + 30, stop_x - 10, stop_y];
          }
        }
      } else {
        if (start_x - stop_x !== 0) {
          if (start_y < stop_y) {
            path = [start_x, start_y + (stop_y - start_y) / 2, stop_x, start_y + (stop_y - start_y) / 2];
          } else {
            path = [start_x, start_y + 10, start_x + (stop_x - start_x) + 12, start_y + 10, stop_x + 12, stop_y - (stop_y - start_y) / 2, stop_x - (stop_x - start_x) / 2, stop_y - (stop_y - start_y) / 2, stop_x - (stop_x - start_x) / 2, stop_y - 10, stop_x, stop_y - 10];
          }
        }
      }
      return path;
    };

    Scheme.selectElement = function(element) {
      console.log(element);
      Scheme.selected_element = element;
      return angular.element('body').scope().onSelectElement();
    };

    Scheme.mouseup = function(e) {
      this.mousemove(e);
      return Scheme.is_drag = false;
    };

    Scheme.elementDblclick = function(e, el) {
      if (el.Root_paper) {
        $('#scheme0').toggle();
        return $('#scheme' + el.Id).toggle();
      }
    };

    Scheme.closeContainer = function() {
      $('#scheme *').hide();
      return $('#scheme0').show();
    };

    Scheme.mousemove = function(e) {
      var color, dot1, dot2, el, link, start_pos, stop_pos, x, y, _i, _len, _ref1;
      if (Scheme.create_link) {
        this.createNewLink(e, Scheme.create_link.dot1);
      }
      if (Scheme.is_drag) {
        x = e.originalEvent.layerX - Scheme.drag_start_pos[0];
        y = e.originalEvent.layerY - Scheme.drag_start_pos[1];
        el = Scheme.selected_element;
        if (Scheme.selected_element._.links) {
          _ref1 = Scheme.selected_element._.links;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            link = _ref1[_i];
            dot1 = link.dot1._.visual;
            dot2 = link.dot2._.visual;
            start_pos = Paper.getRealDotPosition(dot1);
            stop_pos = Paper.getRealDotPosition(dot2);
            if (link.dot1.type === EVENT || link.dot1.type === WORK) {
              color = Scheme.getConf().link.color.events;
            } else {
              color = Scheme.getConf().link.color.vars;
            }
            link.clear();
            Scheme.selected_element._.paper.drawLink(start_pos, stop_pos, color, link);
          }
        }
        return Paper.moveElement(el, x, y);
      }
    };

    Scheme.saveNewLink = function(e, dot2) {
      var class_type_dot1, class_type_dot2, dot1;
      dot1 = Scheme.create_link.dot1;
      class_type_dot1 = dot1.type < 3;
      class_type_dot2 = dot2.type < 3;
      console.log(class_type_dot1, class_type_dot2);
      if (class_type_dot1 === class_type_dot2 && dot1.type !== dot2.type) {
        Scheme.create_link.dot2 = dot2;
        dot2._.element._.links.push(Scheme.create_link);
        dot1._.element._.links.push(Scheme.create_link);
        return Scheme.create_link = void 0;
      }
    };

    Scheme.createNewLink = function(e, dot) {
      var color, dot_position;
      dot_position = Paper.getRealDotPosition(dot._.visual);
      if (dot.type === EVENT || dot.type === WORK) {
        color = Scheme.getConf().link.color.events;
      } else {
        color = Scheme.getConf().link.color.vars;
      }
      if (Scheme.create_link) {
        Scheme.create_link.clear();
        dot._.paper.drawLink(dot_position, [e.global.x, e.global.y], color, Scheme.create_link);
      } else {
        Scheme.create_link = dot._.paper.drawLink(dot_position, [e.global.x, e.global.y], color);
      }
      Scheme.create_link.dot1 = dot;
      return Scheme.create_link;
    };

    Scheme.newLink = function(e, dot) {
      if (!Scheme.create_link) {
        return this.createNewLink(e, dot);
      } else {
        return this.saveNewLink(e, dot);
      }
    };

    Scheme.mousedown = function(e, el) {
      Scheme.selectElement(el);
      return Scheme.is_drag = true;
    };

    Scheme.prototype.load = function(sha) {
      var stats = new Stats();
    stats.setMode(0); // 0: fps, 1: ms

    stats.domElement.style.position = 'fixed';
    stats.domElement.style.left = '0px';
    stats.domElement.style.bottom = '40px';
    document.body.appendChild( stats.domElement );

    setInterval( function () {
      stats.begin();
      stats.end();
    }, 1000 / 60 );;
      var color, eid, element, method, method2, old_paper, result, sortedElements, to, _i, _len, _ref1;
      result = ShaParser.getInstance().Parse(sha);
      this.sdk = result.sdk;
      sortedElements = result.sortedElements;
      this.paper = new Paper();
      for (_i = 0, _len = sortedElements.length; _i < _len; _i++) {
        element = sortedElements[_i];
        if (!element._Container && !element._Root) {
          if (old_paper && !element._Root) {
            this.paper = old_paper;
          }
          this.createElement(element);
        } else {
          if (element._Container) {
            this.createElement(element);
            old_paper = this.paper;
            this.paper = new Paper('#scheme', false, element.Id);
            element.Root_paper = this.paper;
          } else {
            this.paper = element._Root.Root_paper;
            this.createElement(element);
          }
        }
      }
      for (eid in this.sdk.Elements) {
        element = this.sdk.Elements[eid];
        for (method in element.Methods) {
          method = element.Methods[method];
          if (method.to && method.noVisible) {
            console.info(method);
          }
          if (method.noVisible === -1) {
            if (method.to) {
              to = {};
              _ref1 = method.to.split(':'), to.Id = _ref1[0], to.Name = _ref1[1];
              to.Element = this.sdk.Elements[to.Id];
              for (method2 in to.Element.Methods) {
                method2 = to.Element.Methods[method2];
                if (method2.Name === to.Name) {
                  to.Method = method2;
                  break;
                }
              }
              if (method.type === EVENT || method.type === WORK) {
                color = Scheme.getConf().link.color.events;
              } else {
                color = Scheme.getConf().link.color.vars;
              }
              this.drawLink(method, to, color);
            }
          }
        }
      }
      return console.log('SDK', this.sdk);
    };

    Scheme.prototype.createElement = function(element) {
      var dot_color, i, method, mtype, x, y, _results;
      this.sdk.Elements[element.Id] = element;
      this.addElement(element);
      i = [0, 0, 0, 0, 0, 0];
      _results = [];
      for (method in element.Methods) {
        method = element.Methods[method];
        if (method.noVisible === -1) {
          method._ = {
            element: element
          };
          mtype = method.type;
          x = element.X;
          y = element.Y;
          dot_color = Scheme.getConf().dot.color;
          if (mtype === EVENT) {
            x = x + element._.size;
          }
          if (mtype === EVENT || mtype === WORK) {
            y = y + Scheme.getConf().dot.indent + i[method.type] * Scheme.getConf().dot.offset;
          }
          if (mtype === DATA) {
            y = element.Y;
            x = element.X + Scheme.getConf().dot.indent + i[method.type] * Scheme.getConf().dot.offset;
            dot_color = Scheme.getConf().dot.color2;
          }
          if (mtype === VAR) {
            y = element.Y + element._.size;
            x = element.X + Scheme.getConf().dot.indent;
            dot_color = Scheme.getConf().dot.color2;
          }
          this.addDot(method, 1, [x, y], dot_color);
          _results.push(i[method.type]++);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Scheme.prototype.addElement = function(el) {
      var conf, dot, dotname, i, icon_size, method, name, property, size, sub, type, _base, _base1, _i, _j, _k, _l, _len, _len1, _m, _n, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      size = Scheme.getConf().element.size;
      icon_size = Scheme.getConf().icon.size;
      conf = ElementConf.getConf(el.Name);
      if (el._ == null) {
        el._ = {};
      }
      if (el.Property == null) {
        el.Property = {};
      }
      if (el.Methods == null) {
        el.Methods = {};
      }
      el._.links = [];
      el._.conf = conf;
      if (conf.Property == null) {
        conf.Property = {};
      }
      if (conf.Methods == null) {
        conf.Methods = {};
      }
      switch (el._.conf.Type.Class) {
        case 'MultiElement':
          if (el._Container.Property.EventCount) {
            for (i = _i = 1, _ref1 = el._Container.Property.EventCount.Value; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
              name = "onEvent" + i;
              conf.Methods[name] = {
                Name: name,
                type: EVENT,
                noVisible: -1
              };
            }
          }
          if (el._Container.Property.WorkCount) {
            for (i = _j = 1, _ref2 = el._Container.Property.WorkCount.Value; 1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 1 <= _ref2 ? ++_j : --_j) {
              dotname = "doWork" + i;
              conf.Methods[dotname] = {
                Name: dotname,
                type: WORK,
                noVisible: -1
              };
            }
          }
          break;
        case 'DPElement':
          _ref3 = el._.conf.Type.Sub.split(',');
          for (_k = 0, _len = _ref3.length; _k < _len; _k++) {
            sub = _ref3[_k];
            if (sub) {
              _ref4 = sub.split('|'), dot = _ref4[0], name = _ref4[1];
              if (name[0] === 'o') {
                type = EVENT;
              } else {
                type = WORK;
              }
              for (i = _l = 1, _ref5 = el.Property[dot].Value; 1 <= _ref5 ? _l <= _ref5 : _l >= _ref5; i = 1 <= _ref5 ? ++_l : --_l) {
                dotname = "" + name + i;
                conf.Methods[dotname] = {
                  Name: dotname,
                  type: type,
                  noVisible: -1
                };
              }
            }
          }
          break;
        case 'Hub':
          size = 15;
          icon_size = 10;
          _ref6 = el._.conf.Type.Sub.split(',');
          for (_m = 0, _len1 = _ref6.length; _m < _len1; _m++) {
            sub = _ref6[_m];
            if (sub) {
              _ref7 = sub.split('|'), dot = _ref7[0], name = _ref7[1];
              if (name[0] === 'o') {
                type = EVENT;
              } else {
                type = WORK;
              }
              for (i = _n = 1, _ref8 = el.Property[dot].Value; 1 <= _ref8 ? _n <= _ref8 : _n >= _ref8; i = 1 <= _ref8 ? ++_n : --_n) {
                dotname = "" + name + i;
                conf.Methods[dotname] = {
                  Name: dotname,
                  type: type,
                  noVisible: -1
                };
              }
            }
          }
          break;
        case 'EditMulti':
          size = 400;
          icon_size = 0;
      }
      for (method in el.Methods) {
        if ((_base = conf.Methods)[method] == null) {
          _base[method] = {};
        }
        conf.Methods[method].Name = el.Methods[method].Name;
        conf.Methods[method].path = el.Methods[method].path;
        conf.Methods[method].to = el.Methods[method].to;
        conf.Methods[method].noVisible = -1;
      }
      for (property in el.Property) {
        if ((_base1 = conf.Property)[property] == null) {
          _base1[property] = {};
        }
        conf.Property[property].path = el.Property[property].path;
        conf.Property[property].to = el.Property[property].to;
        conf.Property[property].noVisible = -1;
      }
      el._.visual = this.paper.drawElement(el, size, icon_size);
      el._.size = size;
      el._.paper = this.paper;
      el.Property = conf.Property;
      el.Methods = conf.Methods;
      el._.paper = this.paper;
      return el;
    };

    Scheme.prototype.addDot = function(dot, method, position, color) {
      var _base;
      dot.Name = dot.Name.replace(/%(.*)%/gmi, '');
      if ((_base = dot._).type == null) {
        _base.type = method;
      }
      dot._.x = position[0];
      dot._.y = position[1];
      dot._.paper = this.paper;
      return dot._.visual = this.paper.drawDot(dot, method, position, color);
    };

    Scheme.prototype.drawLink = function(method, to, color) {
      var el1, el2, link, start_x, start_y, stop_x, stop_y, _base, _base1;
      if (!to.Method || !to.Method._.x) {
        console.error("точка " + to.Name + " остутствует в " + to.Element.Name);
        return false;
      }
      el1 = method._.element;
      el2 = to.Element;
      start_x = method._.x - getConf().dot.radius.min / 2;
      start_y = method._.y - getConf().dot.radius.min / 2;
      stop_x = to.Method._.x - getConf().dot.radius.min / 2;
      stop_y = to.Method._.y - getConf().dot.radius.min / 2;
      console.log("draw link " + method.Name + "<-->" + to.Name);
      link = el1._.paper.drawLink([start_x, start_y], [stop_x, stop_y], color);
      if ((_base = el1._).links == null) {
        _base.links = [];
      }
      if ((_base1 = el2._).links == null) {
        _base1.links = [];
      }
      el1._.links.push(link);
      el2._.links.push(link);
      method._.link = link;
      to.Method._.link = link;
      link.dot1 = method;
      link.dot2 = to.Method;
      link.el1 = el1;
      return link.el2 = el2;
    };

    return Scheme;

  })();

}).call(this);
